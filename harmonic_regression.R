############################## Harmonic regression #################### 
##
## Performing harmonic regression time series data to evaluate amplitudes and phases.
##
## DATE CREATED: 10/01/2018
## DATE MODIFIED: 04/09/2019
## AUTHORS: Benoit Parmeniter
## Version: 1
## PROJECT: Time series analysis
## ISSUE: 
## TO DO:
##
## COMMIT: exploration of estimation
##

## 
###################################################
#


#https://stackoverflow.com/questions/34444193/fitting-harmonic-model-in-r-of-the-form-asinbxc
#As you dont provide any data, here some simulated data:

set.seed(1)
x <- seq(0, 10, length = 100)
y <- sin(2*x + 5) + rnorm(100, sd=0.5)
y_clean <- sin(2*x + 5)

# Plot of the noised data (y) and the noiseless line (y_clean) which you want to approximate through your model:
plot(x, y, ylim = c(-2,3))
lines(x,y_clean, col = "green")


# Model estimation and adding of the fitted values to the previous plot:
model <- nls(y~a*sin(b*x+c), start = list(a=1,b=1.5, c=1),control = list(maxiter = 500))

lines(x, fitted(model), col = "red")

legend("topright", col=c("green", "red"), legend = c("\"true\" curve", "fitted line"), bty = "n", lty = 1)

n <- length(y)

#first harmonic

p=1 #from 1 to n/2

omega= 2*pi*p/n

t <- 1:n
cos_val =cos(omega*t)
sin_val =sin(omega*t)

in_df <- data.frame(y=y,cos_val=cos_val,sin_val=sin_val)
mod <- lm(y~cos_val + sin_val,data=in_df)

library(TSA)
data(tempdub)
# first creates the first pair of harmonic functions and then fit the model
har.=harmonic(tempdub,1)
model4=lm(tempdub~har.)
summary(model4)
plot(model4)

plot(har.[,1])
plot(har.[,1],type="l")
lines(har.[,2],type="l",col="red")
?harmonic
plot(tempdub)
length(tempdub)

data(tempdub)
month.=season(tempdub) # the period sign is included to make the printout from
# the commands two line below clearer; ditto below.
model2=lm(tempdub~month.-1) # -1 removes the intercept term
summary(model2)

test <- tempdub
test[c(33,45,102,111,137)] <- NA
test
har.=harmonic(test,1)
plot(har.[,1],type="l")

test2 <- harmonic(test,m=2)
test2
dim(test2)
class(test2)

plot(test2[,1],type="l")
lines(test2[,2],type="l",col="pink")
lines(test2[,3],type="l",col="green")
lines(test2[,2],type="l",col="pink")


plot(test2[,1],type="l")
lines(test2[,2],type="l",col="pink")
lines(test2[,3],type="l",col="green")
lines(test2[,2],type="l",col="pink")

harmonic
as.vector(test)

fft(as.vector(test))

###
#A0/2 + Sum(a* cost(rt + b* sin(rt)))

#first harmonic

#https://stat.ethz.ch/pipermail/r-help/2008-May/162879.html

y ~ a + c*sin(x+b)

#so the amplitude of the sine wave is adjustable (otherwise, you assume (or
#                                                                        know) that the amplitude is 1).  Then

y ~ a + c*sin(b)*cos(x) + c*cos(b)*sin(x)
y ~ A0 + b1 cos(x) + b2* sin(x)

#follicles ~ sin(2*pi*Time)+cos(2*pi*Time)
#
#or

y ~ b0 + b1*x1 + b2*x2

#which is a linear regression form that you can do using the lm function.
#After you get b0, b1 and b2 you do

#a = b0
#b1^2 + b2^2 = c^2*(sin^2(b) + cos^2(b)) = c^2  ====> c = sqrt(b1^2 + b2^2)

#b1/b2 = tan(b)  ====>  b = arctan(b1/b2)


x <- 1:12
phase <- 0
a<- 1
b <- 0
T <- 12 #if
y <- a*sin((2*x*pi/T)+ phase) + b

plot(y,type="l")
plot(y~x)

x <- 1:12
phase <- 0
a<- 1
b <- 0
T <- 6 #if
y <- a*sin((x*2*pi/T)+ phase) + b

y
plot(y,type="l")
plot(y~x)

#Generate spatial pattern 5:     
n_col <- ncol(r_init)
n_row <- nrow(r_init)

#u <- xFromCol(r_init,col=1:n_col)
#add padding option later...buffer from a specific distance and tailling of at 0.1
u <- 1:n_col
a<- 1 #amplitude in this case
b<- 0
T<- n_col
phase <- 0
use_cos <- FALSE
ux <- sine_structure_fun(u,T,phase,a,b,use_cos)
ux_rep <-rep(ux,time=n_row)  
r1 <-setValues(r_init,ux_rep)  #note efficient in memory might need to revise this
#plot(r)

v <- 1:n_row
a<- 1 #amplitude in this case
b<- 0
T<- n_row
phase <- 0
use_cos <- FALSE
vx <- sine_structure_fun(v,T,phase,a,b,use_cos)
vx_rep <- unlist((lapply(1:n_row,FUN=function(j){rep(vx[j],time=n_col)})))  



sine_structure_fun <-function(x,T,phase,a,b,use_cos=FALSE){
  
  #Create sine for a one dimensional series
  #Note that sine function uses radian unit.
  #a=amplitude
  #b=mean or amplitude 0 of the series
  #T= stands for period definition
  #phase=phase angle (in radian!!)
  #cos: use cosine instead of sine if TRUE
  
  if(use_cos==FALSE){
    y <- a*sin((x*pi/T)+ phase) + b
  }else{
    y <- a*cos((x*pi/T)+ phase) + b
  }
  return(y)
}


################################### End of script #######################################
